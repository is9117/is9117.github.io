<!DOCTYPE html>
<html lang="ko" prefix="og: http://ogp.me/ns#">
	<head>
		<link href="http://gmpg.org/xfn/11" rel="profile">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta http-equiv="content-type" content="text/html; charset=utf-8">

		<!-- Metadata -->
	<meta name="description" content="">
	<meta property="og:description" content="">
	<meta property="og:title" content="Cache prefetching과 sequential processing의 장점" />
	<meta property="og:type" content="article" />
	<meta property="og:url" content="https://blog.i544c.com/cache-prefetchinggwa-sequential-processingyi-jangjeom.html" />
		<meta property="og:image" content="https://blog.i544c.com/images/profile.jpeg" />

		<!-- Enable responsiveness on mobile devices-->
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

		<title>Isaac's Tech Blog</title>

		<!-- CSS -->
		<link href="//fonts.googleapis.com/" rel="dns-prefetch">
		<link href="//fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic|Abril+Fatface|PT+Sans:400,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet">

		<link rel="stylesheet" href="https://blog.i544c.com/theme/css/poole.css" />
		<link rel="stylesheet" href="https://blog.i544c.com/theme/css/hyde.css" />
		<link rel="stylesheet" href="https://blog.i544c.com/theme/css/syntax.css" />
			<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css" crossorigin="anonymous">

		<!-- Feeds -->
<link href="https://blog.i544c.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Isaac's Tech Blog Full Atom Feed" />
<link href="https://blog.i544c.com/feeds/gisulseutaeg.atom.xml" type="application/atom+xml" rel="alternate" title="Isaac's Tech Blog Categories Atom Feed" />

		<!-- Analytics -->
	</head>

	<body class="theme-base-0d">
<div class="sidebar">
	<div class="container sidebar-sticky">
		<div class="sidebar-about">

			<h1>
				<a href="https://blog.i544c.com/">
					<img class="profile-picture" src="https://blog.i544c.com/images/profile.jpeg">
					Isaac's Tech Blog
				</a>
			</h1>
			<p class="lead"></p>
			<p class="lead"> </p>
			<p></p>
		</div>
			<ul class="sidebar-nav">
			</ul>
		<nav class="sidebar-social">
					<a class="sidebar-social-item" href="mailto:is9117@me.com">
						<i class="fa fa-envelope"></i>
					</a>
					<a class="sidebar-social-item" href="https://x.com/i544c_park" target="_blank">
						<i class="fa fa-twitter"></i>
					</a>
					<a class="sidebar-social-item" href="https://solved.ac/profile/is9117" target="_blank">
						<i class="fa fa-trophy"></i>
					</a>
			<a class="sidebar-social-item" href="https://blog.i544c.com/feeds/all.atom.xml">
				<i class="fa fa-rss"></i>
			</a>
		</nav>
	</div>
</div>		<div class="content container">
<div class="post">
	<h1 class="post-title">Cache prefetching과 sequential processing의 장점</h1>
	<span class="post-date">Mon 07 October 2024</span>
	<hr>
<h2><strong>I. 서론</strong></h2>
<ul>
<li><strong>CPU 캐시 성능의 중요성</strong><ul>
<li>현대 컴퓨팅 환경에서 CPU와 메모리 간의 속도 차이로 인한 성능 병목 현상이 발생합니다.</li>
<li>CPU 캐시는 이러한 속도 격차를 줄여주는 중요한 역할을 합니다.</li>
</ul>
</li>
<li>
<p><strong>캐시 프리패칭과 순차 처리 개요</strong></p>
<ul>
<li>
<p><strong>캐시 프리패칭</strong>: 미래에 필요할 데이터를 미리 캐시에 로드하여 성능을 향상시키는 기술입니다.</p>
<p><img alt="image.png" src="../images/cache_prefeching/image.png"></p>
</li>
<li>
<p><strong>순차 처리</strong>: 데이터 접근 패턴을 최적화하여 캐시 효율을 높이는 방법입니다.</p>
<p><img alt="image.png" src="../images/cache_prefeching/image%201.png"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2><strong>II. 캐시 메모리의 기초</strong></h2>
<ul>
<li>
<p><strong>메모리 계층 구조</strong></p>
<p><img alt="image.png" src="../images/cache_prefeching/image%202.png"></p>
<ul>
<li><strong>레지스터</strong>: CPU 내부에 위치하며 가장 빠른 속도를 가집니다.</li>
<li><strong>캐시 메모리</strong>: L1, L2, L3로 구분되며, CPU와 주 메모리 사이의 속도 격차를 줄여줍니다.</li>
<li><strong>주 메모리(RAM)</strong>: 대용량이지만 상대적으로 느린 속도를 가집니다.</li>
<li><strong>보조 저장소(SSD, HDD)</strong>: 영구적인 데이터 저장소로 가장 느립니다.</li>
<li><strong>캐시 메모리의 역할</strong></li>
<li>자주 사용되는 데이터를 캐시에 저장하여 빠른 데이터 접근을 가능하게 합니다.</li>
<li><strong>공간 지역성</strong>과 <strong>시간 지역성</strong>을 활용합니다.</li>
<li><strong>캐시 미스와 성능 영향</strong></li>
</ul>
<p><img alt="image.png" src="../images/cache_prefeching/image%203.png"></p>
<ul>
<li><strong>캐시 히트</strong>: 필요한 데이터가 캐시에 존재하여 빠르게 접근 가능.</li>
<li><strong>캐시 미스</strong>: 캐시에 데이터가 없어 주 메모리에서 가져와야 함.</li>
<li><strong>미스 패널티</strong>: 캐시 미스로 인한 지연 시간이 성능 저하를 유발합니다.</li>
</ul>
</li>
</ul>
<hr>
<h2><strong>III. 캐시 프리패칭 기술</strong></h2>
<ul>
<li>
<p><strong>캐시 프리패칭이란?</strong></p>
<p><img alt="image.png" src="../images/cache_prefeching/image%204.png"></p>
<ul>
<li>프로그램이 미래에 필요로 할 데이터를 미리 예측하여 캐시에 로드하는 기술입니다.</li>
<li>캐시 미스를 줄이고 데이터 접근 지연을 최소화합니다.</li>
<li><strong>프리패칭의 종류</strong></li>
<li><strong>하드웨어 프리패칭</strong><ul>
<li>CPU 자체에서 프리패칭을 수행합니다.</li>
<li>예측 알고리즘을 통해 다음에 필요한 데이터를 미리 가져옵니다.</li>
<li>프로그래머의 개입 없이 자동으로 작동합니다.</li>
</ul>
</li>
<li><strong>소프트웨어 프리패칭</strong><ul>
<li>프로그래머나 컴파일러가 명시적으로 프리패칭을 구현합니다.</li>
<li>예를 들어, C 언어에서 <code>__builtin_prefetch()</code> 함수를 사용합니다.</li>
<li>애플리케이션 특성에 맞게 최적화할 수 있습니다.</li>
</ul>
</li>
<li><strong>프리패칭 알고리즘</strong></li>
<li><strong>순차 프리패칭</strong><ul>
<li>연속된 메모리 주소에 대한 접근을 예측합니다.</li>
<li>배열이나 리스트의 순차적인 데이터 접근 시 효과적입니다.</li>
</ul>
</li>
<li>
<p><strong>스트라이드 프리패칭</strong></p>
<p><img alt="image.png" src="../images/cache_prefeching/image%205.png"></p>
<ul>
<li>일정한 간격으로 메모리에 접근하는 패턴을 예측합니다.</li>
<li>예를 들어, 2차원 배열의 열을 순회할 때 사용됩니다.<ul>
<li><strong>적응형 프리패칭</strong></li>
</ul>
</li>
<li>프로그램의 실행 패턴을 분석하여 동적으로 프리패칭 전략을 조절합니다.</li>
<li>복잡한 접근 패턴에서도 성능을 향상시킵니다.</li>
<li><strong>프리패칭의 이점과 과제</strong></li>
</ul>
</li>
</ul>
<p><img alt="image.png" src="../images/cache_prefeching/image%206.png"></p>
<ul>
<li><strong>이점</strong><ul>
<li>캐시 미스를 줄여 전반적인 시스템 성능을 향상시킵니다.</li>
<li>CPU의 유휴 시간을 감소시킵니다.</li>
</ul>
</li>
<li><strong>과제</strong><ul>
<li>잘못된 프리패칭은 불필요한 메모리 대역폭을 사용하고 캐시를 오염시킬 수 있습니다.</li>
<li>정확한 예측이 어려운 복잡한 접근 패턴에서는 효과가 제한적입니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2><strong>IV. 순차 처리와 그 이점</strong></h2>
<ul>
<li>
<p><strong>순차 처리의 정의</strong></p>
<ul>
<li>데이터나 명령어를 메모리에 저장된 순서대로 처리하는 방법입니다.</li>
<li><strong>공간 지역성</strong>을 최대한 활용하여 캐시 효율을 높입니다.
  예시) 데이터의 지속성이 있을 경우 + L1, L2 cache가 충분할 경우 huge page를 사용하여 공간 지역성을 살릴 수 있습니다.</li>
</ul>
<p><img alt="image.png" src="../images/cache_prefeching/image%207.png"></p>
</li>
<li>
<p><strong>캐시 성능 향상 방법으로서의 순차 처리</strong></p>
<ul>
<li>연속된 메모리 접근은 캐시 히트율을 높여줍니다.</li>
<li>캐시 라인의 데이터를 최대한 활용하여 메모리 접근 횟수를 줄입니다.</li>
</ul>
</li>
<li><strong>파이썬에서의 순차 처리 적용 방법</strong><ul>
<li><strong>리스트와 배열의 순차 접근</strong><ul>
<li>파이썬 리스트나 <code>numpy</code> 배열을 인덱스를 사용하여 순차적으로 접근합니다.
    <pre><code class="python">
    for i in range(len(data)):
        process(data[i])
    </code></pre></li>
<li>이러한 방식은 메모리 상에서 연속된 데이터에 접근하므로 캐시 효율이 높습니다.</li>
</ul>
</li>
<li><strong>데이터 구조 선택</strong><ul>
<li>연속된 메모리 공간을 사용하는 데이터 구조를 선택합니다.</li>
<li><code>numpy</code> 배열은 C 언어의 배열과 유사하게 메모리에 연속적으로 저장됩니다.</li>
</ul>
</li>
<li><strong>메모리 정렬 및 배치</strong><ul>
<li>데이터의 메모리 배치를 신중하게 설계하여 캐시 미스를 줄입니다.</li>
<li>구조체 배열보다 배열의 구조체를 사용하는 것이 메모리 접근 효율에 유리합니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>순차적이지 않은 처리의 사례</strong><ul>
<li><strong>연결 리스트 사용</strong><ul>
<li>노드들이 메모리 상에서 분산되어 있어 캐시 미스가 증가합니다.
    <pre><code class="python">
    while node is not None:
        process(node.data)
        node = node.next
    </code></pre></li>
<li>메모리 할당이 동적이므로 순차 접근의 이점을 누리기 어렵습니다.</li>
</ul>
</li>
<li><strong>딕셔너리와 세트 사용</strong><ul>
<li>내부적으로 해시 테이블을 사용하여 메모리 접근이 비순차적입니다.</li>
<li>큰 데이터셋의 경우 캐시 효율이 크게 떨어질 수 있습니다.</li>
</ul>
</li>
<li><strong>임의의 인덱스 접근</strong><ul>
<li>리스트나 배열에서 랜덤하게 인덱스로 접근할 때입니다.
    <pre><code class="python">
    for i in random_indices:
        process(data[i])
    </code></pre></li>
<li>데이터가 메모리 상에 연속되어 있어도 접근 패턴이 불규칙하면 캐시 효율이 낮아집니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>실제 프로그램에서의 순차 처리 효과</strong><ul>
<li>
<p><strong>행렬 연산</strong></p>
<p><img alt="image.png" src="../images/cache_prefeching/image%208.png"></p>
<ul>
<li>행 우선 순회와 열 우선 순회에서의 성능 차이.</li>
<li>
<p><code>numpy</code>는 기본적으로 행 우선(C-order)이므로 이에 맞게 데이터 접근.
    <pre><code class="python">
    # 열 우선 접근 (캐시 효율 낮음)
    for j in range(cols):
        for i in range(rows):
            process(matrix[i][j])
    </code></pre></p>
</li>
<li>
<p>행 우선 접근이 캐시 히트율이 높아 성능이 향상됩니다.</p>
<ul>
<li><strong>이미지 처리</strong></li>
</ul>
</li>
</ul>
<p><img alt="image.png" src="../images/cache_prefeching/image%209.png"></p>
<ul>
<li>픽셀 데이터를 순차적으로 처리하여 캐시 미스를 줄입니다.</li>
<li>이미지 필터링이나 변환 작업에서 성능 개선.<ul>
<li><strong>파일 읽기</strong></li>
</ul>
</li>
<li>큰 파일을 읽을 때는 버퍼를 사용하여 블록 단위로 순차적으로 읽습니다.
    <pre><code class="python">
    with open('large_file', 'rb') as f:
        while chunk := f.read(1024 * 1024):
            process(chunk)
    </code></pre></li>
<li>디스크 I/O 효율과 캐시 효율을 모두 높일 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2><strong>V. 캐시 프리패칭과 순차 처리의 결합</strong></h2>
<ul>
<li><strong>두 기술의 시너지 효과</strong><ul>
<li>순차 처리는 프리패처의 예측 정확도를 높여줍니다.</li>
<li>캐시 프리패칭은 순차 처리에서 발생하는 캐시 미스를 더욱 줄여줍니다.</li>
<li>두 기술을 함께 사용하면 캐시 효율을 극대화할 수 있습니다.</li>
</ul>
</li>
<li><strong>실제 응용 분야</strong><ul>
<li><strong>바이너리 버퍼 연산 속도 개선</strong><ul>
<li><strong>대용량 바이너리 데이터 처리</strong>에서 중요한 역할을 합니다.</li>
<li><strong>순차적인 메모리 접근</strong>을 통해 버퍼 연산의 속도를 향상시킵니다.</li>
<li><strong>파일 입출력(IO)</strong>, <strong>네트워크 패킷 처리</strong> 등에서 성능 개선을 이끌어냅니다.</li>
<li>예를 들어, <strong>이미지나 비디오 데이터의 실시간 스트리밍</strong>에서 버퍼링 효율을 높입니다.</li>
</ul>
</li>
<li><strong>고성능 컴퓨팅(HPC)</strong><ul>
<li>대규모 데이터셋을 처리하는 과학 계산에서 필수적입니다.</li>
<li>순차 처리와 프리패칭을 통해 메모리 병목을 최소화합니다.</li>
</ul>
</li>
<li><strong>데이터 집약적 애플리케이션</strong><ul>
<li>머신러닝 모델의 학습 및 추론 시 데이터 로딩 효율을 높입니다.</li>
<li>빅데이터 분석에서의 대용량 데이터 처리 속도 향상.</li>
</ul>
</li>
<li><strong>게임 개발</strong><ul>
<li>실시간 렌더링과 물리 엔진에서 메모리 접근 패턴을 최적화합니다.</li>
<li>프레임 레이트 향상과 렉 감소에 기여합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2>VI. 테스트</h2>
<h3><strong>numpy로 캐시 프리패칭 효과를 보여주는 예제</strong></h3>
<p><strong>제약 사항:</strong></p>
<ul>
<li>파이썬 인터프리터의 오버헤드로 인해, <strong>순수 파이썬으로 캐시 프리패칭의 효과를 명확하게 보여주기</strong>는 어렵습니다.</li>
<li>상대적인 성능 차이를 관찰할 수 있는 간단한 예제</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># 데이터 크기 설정</span>
<span class="n">data_size</span> <span class="o">=</span> <span class="mi">10_000_000</span>

<span class="c1"># NumPy 배열 생성</span>
<span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># 순차 접근 함수</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sequential_access</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="c1"># 랜덤 인덱스 생성</span>
<span class="n">random_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_size</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_indices</span><span class="p">)</span>

<span class="c1"># 랜덤 접근 함수</span>
<span class="k">def</span><span class="w"> </span><span class="nf">random_access</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="c1"># 순차 접근 시간 측정</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">sequential_access</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span>
<span class="n">seq_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;순차 접근 시간: </span><span class="si">{</span><span class="n">seq_time</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">초&quot;</span><span class="p">)</span>

<span class="c1"># 순차 접근(per element) 시간 측정</span>
<span class="n">per_element_time</span> <span class="o">=</span> <span class="n">seq_time</span> <span class="o">/</span> <span class="n">data_size</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;순차 접근(per element) 시간: </span><span class="si">{</span><span class="n">per_element_time</span><span class="o">*</span><span class="mi">1_000_000_000</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">ns&quot;</span><span class="p">)</span>

<span class="c1"># 랜덤 접근 시간 측정</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">random_access</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="n">random_indices</span><span class="p">)</span>
<span class="n">rand_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;랜덤 접근 시간: </span><span class="si">{</span><span class="n">rand_time</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">초&quot;</span><span class="p">)</span>

<span class="c1"># 랜덤 접근(per element) 시간 측정</span>
<span class="n">per_element_time</span> <span class="o">=</span> <span class="n">rand_time</span> <span class="o">/</span> <span class="n">data_size</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;랜덤 접근(per element) 시간: </span><span class="si">{</span><span class="n">per_element_time</span><span class="o">*</span><span class="mi">1_000_000_000</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">ns&quot;</span><span class="p">)</span>

<span class="c1"># 성능 비교</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">랜덤 접근은 순차 접근보다 </span><span class="si">{</span><span class="n">rand_time</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">seq_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">배 느립니다.&quot;</span><span class="p">)</span>
</code></pre></div>

<p><img alt="image.png" src="../images/cache_prefeching/image%2010.png"></p>
<h3>순차 검색이 정렬 및 이진 검색보다 빠른 경우를 보여주는 코드 예제</h3>
<p>일반적으로 <strong>이진 검색</strong>은 <strong>정렬된 데이터</strong>에서 원하는 값을 빠르게 찾을 수 있는 효율적인 알고리즘입니다. 그러나 데이터가 정렬되어 있지 않은 경우, <strong>데이터를 정렬하는 비용</strong>이 추가됩니다. 작은 데이터셋이나 특정 상황에서는 <strong>순차 검색(Linear Search)</strong>이 전체적으로 더 빠를 수 있습니다.</p>
<p>또한, 순차 검색은 <strong>연속된 메모리 접근</strong>을 하므로 <strong>캐시 프리패칭</strong>의 이점을 누릴 수 있습니다. 반면, 이진 검색은 메모리 접근 패턴이 불규칙하여 캐시 미스가 증가할 수 있습니다.</p>
<p>python으로는 정확한 cache prefetching테스트가 어려워, C로 진행합니다.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>

<span class="c1">// 순차 검색 함수</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sequential_search</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 이진 검색 함수</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">binary_search</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 비교 함수 (qsort에 사용)</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">compare_ints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arg1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arg1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span><span class="w"> </span><span class="c1">// 백만 개의 요소</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_trials</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">     </span><span class="c1">// 반복 횟수 설정</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_seq_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_sort_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_bin_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 난수 시드 설정</span>
<span class="w">    </span><span class="n">srand</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">trial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">trial</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_trials</span><span class="p">;</span><span class="w"> </span><span class="n">trial</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">data_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;메모리 할당 실패</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 데이터셋 생성 (랜덤 정수)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">data_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 검색할 값 설정 (데이터셋에 존재하는 값)</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">target_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">data_size</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">target_index</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// 순차 검색 시간 측정</span>
<span class="w">        </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sequential_search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">data_size</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">);</span>
<span class="w">        </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">end_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">time_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_seq</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_seq</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 밀리초 단위</span>

<span class="w">        </span><span class="c1">// 데이터 정렬 시간 측정</span>
<span class="w">        </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start_sort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="n">qsort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">data_size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">compare_ints</span><span class="p">);</span>
<span class="w">        </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">end_sort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">time_sort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_sort</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_sort</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 밀리초 단위</span>

<span class="w">        </span><span class="c1">// 이진 검색 시간 측정</span>
<span class="w">        </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start_bin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index_bin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binary_search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">data_size</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">);</span>
<span class="w">        </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">end_bin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">time_bin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_bin</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_bin</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 밀리초 단위</span>

<span class="w">        </span><span class="c1">// 총 시간 누적</span>
<span class="w">        </span><span class="n">total_seq_time</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">time_seq</span><span class="p">;</span>
<span class="w">        </span><span class="n">total_sort_time</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">time_sort</span><span class="p">;</span>
<span class="w">        </span><span class="n">total_bin_time</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">time_bin</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 메모리 해제</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 평균 시간 계산</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">avg_seq_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_seq_time</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_trials</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">avg_sort_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_sort_time</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_trials</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">avg_bin_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_bin_time</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_trials</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">avg_total_bin_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avg_sort_time</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">avg_bin_time</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 결과 출력</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;실행 횟수: %d회</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num_trials</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;순차 검색 평균 시간: %.6fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">avg_seq_time</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;데이터 정렬 평균 시간: %.6fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">avg_sort_time</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;이진 검색 평균 시간: %.6fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">avg_bin_time</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">순차 검색 평균 총 시간: %.6fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">avg_seq_time</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;정렬 + 이진 검색 평균 총 시간: %.6fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">avg_total_bin_time</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avg_seq_time</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">avg_total_bin_time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">순차 검색이 전체적으로 더 빠릅니다.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">정렬 후 이진 검색이 전체적으로 더 빠릅니다.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="nv">CC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>gcc
<span class="nv">CFLAGS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-O2<span class="w"> </span>-Wall
<span class="nv">TARGET</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">test</span>

<span class="nf">all</span><span class="o">:</span><span class="w"> </span><span class="k">$(</span><span class="nv">TARGET</span><span class="k">)</span>

<span class="nf">$(TARGET)</span><span class="o">:</span><span class="w"> </span><span class="n">test</span>.<span class="n">c</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span>-o<span class="w"> </span><span class="k">$(</span>TARGET<span class="k">)</span><span class="w"> </span>test.c

<span class="nf">clean</span><span class="o">:</span>
<span class="w">    </span>rm<span class="w"> </span>-f<span class="w"> </span><span class="k">$(</span>TARGET<span class="k">)</span>
</code></pre></div>

<p><img alt="image.png" src="../images/cache_prefeching/image%2011.png"></p>

		<span class="post-tags">
			Tags:
			<ul>
					<li><a href="https://blog.i544c.com/tag/backend.html">backend</a></li>
					<li><a href="https://blog.i544c.com/tag/data-structure.html">data structure</a></li>
					<li><a href="https://blog.i544c.com/tag/profiling.html">profiling</a></li>
					<li><a href="https://blog.i544c.com/tag/python.html">python</a></li>
			</ul>
		</span>

</div>
		</div>
		<script>
		(function() {
			function getCookie(name) {
			const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
			return match ? match[2] : null;
			}

			function setCookie(name, value, days) {
			const expires = new Date(Date.now() + days * 864e5).toUTCString();
			document.cookie = name + '=' + value + '; expires=' + expires + '; path=/; domain=.i544c.com';
			}

			let visitorId = getCookie('visitor_id');
			if (!visitorId) {
			visitorId = crypto.randomUUID();
			setCookie('visitor_id', visitorId, 365);
			}

			const payload = {
			path: window.location.pathname,
			visitor_id: visitorId,
			date: new Date().toISOString().slice(0, 10)  // "YYYY-MM-DD"
			};

			fetch("https://api.i544c.com/count", {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(payload)
			}).catch(err => console.error("Failed to POST visitor", err));
		})();
		</script>
	</body>
</html>